// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v3.21.12
// source: common/configtx.proto

package common

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ConfigEnvelope is designed to contain _all_ configuration for a chain with no dependency
// on previous configuration transactions.
//
// It is generated with the following scheme:
//  1. Retrieve the existing configuration
//  2. Note the config properties (ConfigValue, ConfigPolicy, ConfigGroup) to be modified
//  3. Add any intermediate ConfigGroups to the ConfigUpdate.read_set (sparsely)
//  4. Add any additional desired dependencies to ConfigUpdate.read_set (sparsely)
//  5. Modify the config properties, incrementing each version by 1, set them in the ConfigUpdate.write_set
//     Note: any element not modified but specified should already be in the read_set, so may be specified sparsely
//  6. Create ConfigUpdate message and marshal it into ConfigUpdateEnvelope.update and encode the required signatures
//     a) Each signature is of type ConfigSignature
//     b) The ConfigSignature signature is over the concatenation of signature_header and the ConfigUpdate bytes (which includes a ChainHeader)
//  5. Submit new Config for ordering in Envelope signed by submitter
//     a) The Envelope Payload has data set to the marshaled ConfigEnvelope
//     b) The Envelope Payload has a header of type Header.Type.CONFIG_UPDATE
//
// The configuration manager will verify:
//  1. All items in the read_set exist at the read versions
//  2. All items in the write_set at a different version than, or not in, the read_set have been appropriately signed according to their mod_policy
//  3. The new configuration satisfies the ConfigSchema
type ConfigEnvelope struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Config        *Config                `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`                           // A marshaled Config structure
	LastUpdate    *Envelope              `protobuf:"bytes,2,opt,name=last_update,json=lastUpdate,proto3" json:"last_update,omitempty"` // The last CONFIG_UPDATE message which generated this current configuration
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConfigEnvelope) Reset() {
	*x = ConfigEnvelope{}
	mi := &file_common_configtx_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConfigEnvelope) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfigEnvelope) ProtoMessage() {}

func (x *ConfigEnvelope) ProtoReflect() protoreflect.Message {
	mi := &file_common_configtx_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfigEnvelope.ProtoReflect.Descriptor instead.
func (*ConfigEnvelope) Descriptor() ([]byte, []int) {
	return file_common_configtx_proto_rawDescGZIP(), []int{0}
}

func (x *ConfigEnvelope) GetConfig() *Config {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *ConfigEnvelope) GetLastUpdate() *Envelope {
	if x != nil {
		return x.LastUpdate
	}
	return nil
}

// Config represents the config for a particular channel
type Config struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Sequence      uint64                 `protobuf:"varint,1,opt,name=sequence,proto3" json:"sequence,omitempty"`
	ChannelGroup  *ConfigGroup           `protobuf:"bytes,2,opt,name=channel_group,json=channelGroup,proto3" json:"channel_group,omitempty"` // channel_group is a bad name for this, it should be changed to root when API breakage is allowed
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Config) Reset() {
	*x = Config{}
	mi := &file_common_configtx_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config) ProtoMessage() {}

func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_common_configtx_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_common_configtx_proto_rawDescGZIP(), []int{1}
}

func (x *Config) GetSequence() uint64 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *Config) GetChannelGroup() *ConfigGroup {
	if x != nil {
		return x.ChannelGroup
	}
	return nil
}

type ConfigUpdateEnvelope struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ConfigUpdate  []byte                 `protobuf:"bytes,1,opt,name=config_update,json=configUpdate,proto3" json:"config_update,omitempty"` // A marshaled ConfigUpdate structure
	Signatures    []*ConfigSignature     `protobuf:"bytes,2,rep,name=signatures,proto3" json:"signatures,omitempty"`                         // Signatures over the config_update
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConfigUpdateEnvelope) Reset() {
	*x = ConfigUpdateEnvelope{}
	mi := &file_common_configtx_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConfigUpdateEnvelope) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfigUpdateEnvelope) ProtoMessage() {}

func (x *ConfigUpdateEnvelope) ProtoReflect() protoreflect.Message {
	mi := &file_common_configtx_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfigUpdateEnvelope.ProtoReflect.Descriptor instead.
func (*ConfigUpdateEnvelope) Descriptor() ([]byte, []int) {
	return file_common_configtx_proto_rawDescGZIP(), []int{2}
}

func (x *ConfigUpdateEnvelope) GetConfigUpdate() []byte {
	if x != nil {
		return x.ConfigUpdate
	}
	return nil
}

func (x *ConfigUpdateEnvelope) GetSignatures() []*ConfigSignature {
	if x != nil {
		return x.Signatures
	}
	return nil
}

// ConfigUpdate is used to submit a subset of config and to have the orderer apply to Config
// it is always submitted inside a ConfigUpdateEnvelope which allows the addition of signatures
// resulting in a new total configuration.  The update is applied as follows:
//  1. The versions from all of the elements in the read_set is verified against the versions in the existing config.
//     If there is a mismatch in the read versions, then the config update fails and is rejected.
//  2. Any elements in the write_set with the same version as the read_set are ignored.
//  3. The corresponding mod_policy for every remaining element in the write_set is collected.
//  4. Each policy is checked against the signatures from the ConfigUpdateEnvelope, any failing to verify are rejected
//  5. The write_set is applied to the Config and the ConfigGroupSchema verifies that the updates were legal
type ConfigUpdate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ChannelId     string                 `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`                                                                                    // Which channel this config update is for
	ReadSet       *ConfigGroup           `protobuf:"bytes,2,opt,name=read_set,json=readSet,proto3" json:"read_set,omitempty"`                                                                                          // ReadSet explicitly lists the portion of the config which was read, this should be sparse with only Version set
	WriteSet      *ConfigGroup           `protobuf:"bytes,3,opt,name=write_set,json=writeSet,proto3" json:"write_set,omitempty"`                                                                                       // WriteSet lists the portion of the config which was written, this should included updated Versions
	IsolatedData  map[string][]byte      `protobuf:"bytes,5,rep,name=isolated_data,json=isolatedData,proto3" json:"isolated_data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Data which is not to be reflected in the resulting Config, but is still needed for some other purpose.  For instance, rscc_seed_data
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConfigUpdate) Reset() {
	*x = ConfigUpdate{}
	mi := &file_common_configtx_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConfigUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfigUpdate) ProtoMessage() {}

func (x *ConfigUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_common_configtx_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfigUpdate.ProtoReflect.Descriptor instead.
func (*ConfigUpdate) Descriptor() ([]byte, []int) {
	return file_common_configtx_proto_rawDescGZIP(), []int{3}
}

func (x *ConfigUpdate) GetChannelId() string {
	if x != nil {
		return x.ChannelId
	}
	return ""
}

func (x *ConfigUpdate) GetReadSet() *ConfigGroup {
	if x != nil {
		return x.ReadSet
	}
	return nil
}

func (x *ConfigUpdate) GetWriteSet() *ConfigGroup {
	if x != nil {
		return x.WriteSet
	}
	return nil
}

func (x *ConfigUpdate) GetIsolatedData() map[string][]byte {
	if x != nil {
		return x.IsolatedData
	}
	return nil
}

// ConfigGroup is the hierarchical data structure for holding config
type ConfigGroup struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	Version       uint64                   `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Groups        map[string]*ConfigGroup  `protobuf:"bytes,2,rep,name=groups,proto3" json:"groups,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Values        map[string]*ConfigValue  `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Policies      map[string]*ConfigPolicy `protobuf:"bytes,4,rep,name=policies,proto3" json:"policies,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ModPolicy     string                   `protobuf:"bytes,5,opt,name=mod_policy,json=modPolicy,proto3" json:"mod_policy,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConfigGroup) Reset() {
	*x = ConfigGroup{}
	mi := &file_common_configtx_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConfigGroup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfigGroup) ProtoMessage() {}

func (x *ConfigGroup) ProtoReflect() protoreflect.Message {
	mi := &file_common_configtx_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfigGroup.ProtoReflect.Descriptor instead.
func (*ConfigGroup) Descriptor() ([]byte, []int) {
	return file_common_configtx_proto_rawDescGZIP(), []int{4}
}

func (x *ConfigGroup) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *ConfigGroup) GetGroups() map[string]*ConfigGroup {
	if x != nil {
		return x.Groups
	}
	return nil
}

func (x *ConfigGroup) GetValues() map[string]*ConfigValue {
	if x != nil {
		return x.Values
	}
	return nil
}

func (x *ConfigGroup) GetPolicies() map[string]*ConfigPolicy {
	if x != nil {
		return x.Policies
	}
	return nil
}

func (x *ConfigGroup) GetModPolicy() string {
	if x != nil {
		return x.ModPolicy
	}
	return ""
}

// ConfigValue represents an individual piece of config data
type ConfigValue struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Version       uint64                 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Value         []byte                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	ModPolicy     string                 `protobuf:"bytes,3,opt,name=mod_policy,json=modPolicy,proto3" json:"mod_policy,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConfigValue) Reset() {
	*x = ConfigValue{}
	mi := &file_common_configtx_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConfigValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfigValue) ProtoMessage() {}

func (x *ConfigValue) ProtoReflect() protoreflect.Message {
	mi := &file_common_configtx_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfigValue.ProtoReflect.Descriptor instead.
func (*ConfigValue) Descriptor() ([]byte, []int) {
	return file_common_configtx_proto_rawDescGZIP(), []int{5}
}

func (x *ConfigValue) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *ConfigValue) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *ConfigValue) GetModPolicy() string {
	if x != nil {
		return x.ModPolicy
	}
	return ""
}

type ConfigPolicy struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Version       uint64                 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Policy        *Policy                `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
	ModPolicy     string                 `protobuf:"bytes,3,opt,name=mod_policy,json=modPolicy,proto3" json:"mod_policy,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConfigPolicy) Reset() {
	*x = ConfigPolicy{}
	mi := &file_common_configtx_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConfigPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfigPolicy) ProtoMessage() {}

func (x *ConfigPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_common_configtx_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfigPolicy.ProtoReflect.Descriptor instead.
func (*ConfigPolicy) Descriptor() ([]byte, []int) {
	return file_common_configtx_proto_rawDescGZIP(), []int{6}
}

func (x *ConfigPolicy) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *ConfigPolicy) GetPolicy() *Policy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *ConfigPolicy) GetModPolicy() string {
	if x != nil {
		return x.ModPolicy
	}
	return ""
}

type ConfigSignature struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	SignatureHeader []byte                 `protobuf:"bytes,1,opt,name=signature_header,json=signatureHeader,proto3" json:"signature_header,omitempty"` // A marshaled SignatureHeader
	Signature       []byte                 `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`                                    // Signature over the concatenation signatureHeader bytes and config bytes
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ConfigSignature) Reset() {
	*x = ConfigSignature{}
	mi := &file_common_configtx_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConfigSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfigSignature) ProtoMessage() {}

func (x *ConfigSignature) ProtoReflect() protoreflect.Message {
	mi := &file_common_configtx_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfigSignature.ProtoReflect.Descriptor instead.
func (*ConfigSignature) Descriptor() ([]byte, []int) {
	return file_common_configtx_proto_rawDescGZIP(), []int{7}
}

func (x *ConfigSignature) GetSignatureHeader() []byte {
	if x != nil {
		return x.SignatureHeader
	}
	return nil
}

func (x *ConfigSignature) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

var File_common_configtx_proto protoreflect.FileDescriptor

const file_common_configtx_proto_rawDesc = "" +
	"\n" +
	"\x15common/configtx.proto\x12\x06common\x1a\x13common/common.proto\x1a\x15common/policies.proto\"k\n" +
	"\x0eConfigEnvelope\x12&\n" +
	"\x06config\x18\x01 \x01(\v2\x0e.common.ConfigR\x06config\x121\n" +
	"\vlast_update\x18\x02 \x01(\v2\x10.common.EnvelopeR\n" +
	"lastUpdate\"j\n" +
	"\x06Config\x12\x1a\n" +
	"\bsequence\x18\x01 \x01(\x04R\bsequence\x128\n" +
	"\rchannel_group\x18\x02 \x01(\v2\x13.common.ConfigGroupR\fchannelGroupJ\x04\b\x03\x10\x04R\x04type\"t\n" +
	"\x14ConfigUpdateEnvelope\x12#\n" +
	"\rconfig_update\x18\x01 \x01(\fR\fconfigUpdate\x127\n" +
	"\n" +
	"signatures\x18\x02 \x03(\v2\x17.common.ConfigSignatureR\n" +
	"signatures\"\xa9\x02\n" +
	"\fConfigUpdate\x12\x1d\n" +
	"\n" +
	"channel_id\x18\x01 \x01(\tR\tchannelId\x12.\n" +
	"\bread_set\x18\x02 \x01(\v2\x13.common.ConfigGroupR\areadSet\x120\n" +
	"\twrite_set\x18\x03 \x01(\v2\x13.common.ConfigGroupR\bwriteSet\x12K\n" +
	"\risolated_data\x18\x05 \x03(\v2&.common.ConfigUpdate.IsolatedDataEntryR\fisolatedData\x1a?\n" +
	"\x11IsolatedDataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01J\x04\b\x04\x10\x05R\x04type\"\xea\x03\n" +
	"\vConfigGroup\x12\x18\n" +
	"\aversion\x18\x01 \x01(\x04R\aversion\x127\n" +
	"\x06groups\x18\x02 \x03(\v2\x1f.common.ConfigGroup.GroupsEntryR\x06groups\x127\n" +
	"\x06values\x18\x03 \x03(\v2\x1f.common.ConfigGroup.ValuesEntryR\x06values\x12=\n" +
	"\bpolicies\x18\x04 \x03(\v2!.common.ConfigGroup.PoliciesEntryR\bpolicies\x12\x1d\n" +
	"\n" +
	"mod_policy\x18\x05 \x01(\tR\tmodPolicy\x1aN\n" +
	"\vGroupsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12)\n" +
	"\x05value\x18\x02 \x01(\v2\x13.common.ConfigGroupR\x05value:\x028\x01\x1aN\n" +
	"\vValuesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12)\n" +
	"\x05value\x18\x02 \x01(\v2\x13.common.ConfigValueR\x05value:\x028\x01\x1aQ\n" +
	"\rPoliciesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12*\n" +
	"\x05value\x18\x02 \x01(\v2\x14.common.ConfigPolicyR\x05value:\x028\x01\"\\\n" +
	"\vConfigValue\x12\x18\n" +
	"\aversion\x18\x01 \x01(\x04R\aversion\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value\x12\x1d\n" +
	"\n" +
	"mod_policy\x18\x03 \x01(\tR\tmodPolicy\"o\n" +
	"\fConfigPolicy\x12\x18\n" +
	"\aversion\x18\x01 \x01(\x04R\aversion\x12&\n" +
	"\x06policy\x18\x02 \x01(\v2\x0e.common.PolicyR\x06policy\x12\x1d\n" +
	"\n" +
	"mod_policy\x18\x03 \x01(\tR\tmodPolicy\"Z\n" +
	"\x0fConfigSignature\x12)\n" +
	"\x10signature_header\x18\x01 \x01(\fR\x0fsignatureHeader\x12\x1c\n" +
	"\tsignature\x18\x02 \x01(\fR\tsignatureBV\n" +
	"$org.hyperledger.fabric.protos.commonZ.github.com/hyperledger/fabric-protos-go/commonb\x06proto3"

var (
	file_common_configtx_proto_rawDescOnce sync.Once
	file_common_configtx_proto_rawDescData []byte
)

func file_common_configtx_proto_rawDescGZIP() []byte {
	file_common_configtx_proto_rawDescOnce.Do(func() {
		file_common_configtx_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_common_configtx_proto_rawDesc), len(file_common_configtx_proto_rawDesc)))
	})
	return file_common_configtx_proto_rawDescData
}

var file_common_configtx_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_common_configtx_proto_goTypes = []any{
	(*ConfigEnvelope)(nil),       // 0: common.ConfigEnvelope
	(*Config)(nil),               // 1: common.Config
	(*ConfigUpdateEnvelope)(nil), // 2: common.ConfigUpdateEnvelope
	(*ConfigUpdate)(nil),         // 3: common.ConfigUpdate
	(*ConfigGroup)(nil),          // 4: common.ConfigGroup
	(*ConfigValue)(nil),          // 5: common.ConfigValue
	(*ConfigPolicy)(nil),         // 6: common.ConfigPolicy
	(*ConfigSignature)(nil),      // 7: common.ConfigSignature
	nil,                          // 8: common.ConfigUpdate.IsolatedDataEntry
	nil,                          // 9: common.ConfigGroup.GroupsEntry
	nil,                          // 10: common.ConfigGroup.ValuesEntry
	nil,                          // 11: common.ConfigGroup.PoliciesEntry
	(*Envelope)(nil),             // 12: common.Envelope
	(*Policy)(nil),               // 13: common.Policy
}
var file_common_configtx_proto_depIdxs = []int32{
	1,  // 0: common.ConfigEnvelope.config:type_name -> common.Config
	12, // 1: common.ConfigEnvelope.last_update:type_name -> common.Envelope
	4,  // 2: common.Config.channel_group:type_name -> common.ConfigGroup
	7,  // 3: common.ConfigUpdateEnvelope.signatures:type_name -> common.ConfigSignature
	4,  // 4: common.ConfigUpdate.read_set:type_name -> common.ConfigGroup
	4,  // 5: common.ConfigUpdate.write_set:type_name -> common.ConfigGroup
	8,  // 6: common.ConfigUpdate.isolated_data:type_name -> common.ConfigUpdate.IsolatedDataEntry
	9,  // 7: common.ConfigGroup.groups:type_name -> common.ConfigGroup.GroupsEntry
	10, // 8: common.ConfigGroup.values:type_name -> common.ConfigGroup.ValuesEntry
	11, // 9: common.ConfigGroup.policies:type_name -> common.ConfigGroup.PoliciesEntry
	13, // 10: common.ConfigPolicy.policy:type_name -> common.Policy
	4,  // 11: common.ConfigGroup.GroupsEntry.value:type_name -> common.ConfigGroup
	5,  // 12: common.ConfigGroup.ValuesEntry.value:type_name -> common.ConfigValue
	6,  // 13: common.ConfigGroup.PoliciesEntry.value:type_name -> common.ConfigPolicy
	14, // [14:14] is the sub-list for method output_type
	14, // [14:14] is the sub-list for method input_type
	14, // [14:14] is the sub-list for extension type_name
	14, // [14:14] is the sub-list for extension extendee
	0,  // [0:14] is the sub-list for field type_name
}

func init() { file_common_configtx_proto_init() }
func file_common_configtx_proto_init() {
	if File_common_configtx_proto != nil {
		return
	}
	file_common_common_proto_init()
	file_common_policies_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_common_configtx_proto_rawDesc), len(file_common_configtx_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_common_configtx_proto_goTypes,
		DependencyIndexes: file_common_configtx_proto_depIdxs,
		MessageInfos:      file_common_configtx_proto_msgTypes,
	}.Build()
	File_common_configtx_proto = out.File
	file_common_configtx_proto_goTypes = nil
	file_common_configtx_proto_depIdxs = nil
}
