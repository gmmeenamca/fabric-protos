// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v3.21.12
// source: peer/proposal_response.proto

package peer

import (
	common "github.com/hyperledger/fabric-protos-go/common"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// A ProposalResponse is returned from an endorser to the proposal submitter.
// The idea is that this message contains the endorser's response to the
// request of a client to perform an action over a chaincode (or more
// generically on the ledger); the response might be success/error (conveyed in
// the Response field) together with a description of the action and a
// signature over it by that endorser.  If a sufficient number of distinct
// endorsers agree on the same action and produce signature to that effect, a
// transaction can be generated and sent for ordering.
type ProposalResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Version indicates message protocol version
	Version int32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// Timestamp is the time that the message
	// was created as  defined by the sender
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// A response message indicating whether the
	// endorsement of the action was successful
	Response *Response `protobuf:"bytes,4,opt,name=response,proto3" json:"response,omitempty"`
	// The payload of response. It is the bytes of ProposalResponsePayload
	Payload []byte `protobuf:"bytes,5,opt,name=payload,proto3" json:"payload,omitempty"`
	// The endorsement of the proposal, basically
	// the endorser's signature over the payload
	Endorsement *Endorsement `protobuf:"bytes,6,opt,name=endorsement,proto3" json:"endorsement,omitempty"`
	// The chaincode interest derived from simulating the proposal.
	Interest      *ChaincodeInterest `protobuf:"bytes,7,opt,name=interest,proto3" json:"interest,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProposalResponse) Reset() {
	*x = ProposalResponse{}
	mi := &file_peer_proposal_response_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProposalResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProposalResponse) ProtoMessage() {}

func (x *ProposalResponse) ProtoReflect() protoreflect.Message {
	mi := &file_peer_proposal_response_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProposalResponse.ProtoReflect.Descriptor instead.
func (*ProposalResponse) Descriptor() ([]byte, []int) {
	return file_peer_proposal_response_proto_rawDescGZIP(), []int{0}
}

func (x *ProposalResponse) GetVersion() int32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *ProposalResponse) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *ProposalResponse) GetResponse() *Response {
	if x != nil {
		return x.Response
	}
	return nil
}

func (x *ProposalResponse) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ProposalResponse) GetEndorsement() *Endorsement {
	if x != nil {
		return x.Endorsement
	}
	return nil
}

func (x *ProposalResponse) GetInterest() *ChaincodeInterest {
	if x != nil {
		return x.Interest
	}
	return nil
}

// A response with a representation similar to an HTTP response that can
// be used within another message.
type Response struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A status code that should follow the HTTP status codes.
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// A message associated with the response code.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// A payload that can be used to include metadata with this response.
	Payload       []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Response) Reset() {
	*x = Response{}
	mi := &file_peer_proposal_response_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Response) ProtoMessage() {}

func (x *Response) ProtoReflect() protoreflect.Message {
	mi := &file_peer_proposal_response_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Response.ProtoReflect.Descriptor instead.
func (*Response) Descriptor() ([]byte, []int) {
	return file_peer_proposal_response_proto_rawDescGZIP(), []int{1}
}

func (x *Response) GetStatus() int32 {
	if x != nil {
		return x.Status
	}
	return 0
}

func (x *Response) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *Response) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

// ProposalResponsePayload is the payload of a proposal response.  This message
// is the "bridge" between the client's request and the endorser's action in
// response to that request. Concretely, for chaincodes, it contains a hashed
// representation of the proposal (proposalHash) and a representation of the
// chaincode state changes and events inside the extension field.
type ProposalResponsePayload struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Hash of the proposal that triggered this response. The hash is used to
	// link a response with its proposal, both for bookeeping purposes on an
	// asynchronous system and for security reasons (accountability,
	// non-repudiation). The hash usually covers the entire Proposal message
	// (byte-by-byte).
	ProposalHash []byte `protobuf:"bytes,1,opt,name=proposal_hash,json=proposalHash,proto3" json:"proposal_hash,omitempty"`
	// Extension should be unmarshaled to a type-specific message. The type of
	// the extension in any proposal response depends on the type of the proposal
	// that the client selected when the proposal was initially sent out.  In
	// particular, this information is stored in the type field of a Header.  For
	// chaincode, it's a ChaincodeAction message
	Extension     []byte `protobuf:"bytes,2,opt,name=extension,proto3" json:"extension,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProposalResponsePayload) Reset() {
	*x = ProposalResponsePayload{}
	mi := &file_peer_proposal_response_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProposalResponsePayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProposalResponsePayload) ProtoMessage() {}

func (x *ProposalResponsePayload) ProtoReflect() protoreflect.Message {
	mi := &file_peer_proposal_response_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProposalResponsePayload.ProtoReflect.Descriptor instead.
func (*ProposalResponsePayload) Descriptor() ([]byte, []int) {
	return file_peer_proposal_response_proto_rawDescGZIP(), []int{2}
}

func (x *ProposalResponsePayload) GetProposalHash() []byte {
	if x != nil {
		return x.ProposalHash
	}
	return nil
}

func (x *ProposalResponsePayload) GetExtension() []byte {
	if x != nil {
		return x.Extension
	}
	return nil
}

// An endorsement is a signature of an endorser over a proposal response.  By
// producing an endorsement message, an endorser implicitly "approves" that
// proposal response and the actions contained therein. When enough
// endorsements have been collected, a transaction can be generated out of a
// set of proposal responses.  Note that this message only contains an identity
// and a signature but no signed payload. This is intentional because
// endorsements are supposed to be collected in a transaction, and they are all
// expected to endorse a single proposal response/action (many endorsements
// over a single proposal response)
type Endorsement struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identity of the endorser (e.g. its certificate)
	Endorser []byte `protobuf:"bytes,1,opt,name=endorser,proto3" json:"endorser,omitempty"`
	// Signature of the payload included in ProposalResponse concatenated with
	// the endorser's certificate; ie, sign(ProposalResponse.payload + endorser)
	Signature     []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Endorsement) Reset() {
	*x = Endorsement{}
	mi := &file_peer_proposal_response_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Endorsement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Endorsement) ProtoMessage() {}

func (x *Endorsement) ProtoReflect() protoreflect.Message {
	mi := &file_peer_proposal_response_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Endorsement.ProtoReflect.Descriptor instead.
func (*Endorsement) Descriptor() ([]byte, []int) {
	return file_peer_proposal_response_proto_rawDescGZIP(), []int{3}
}

func (x *Endorsement) GetEndorser() []byte {
	if x != nil {
		return x.Endorser
	}
	return nil
}

func (x *Endorsement) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

// ChaincodeInterest defines an interest about an endorsement
// for a specific single chaincode invocation.
// Multiple chaincodes indicate chaincode to chaincode invocations.
type ChaincodeInterest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Chaincodes    []*ChaincodeCall       `protobuf:"bytes,1,rep,name=chaincodes,proto3" json:"chaincodes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChaincodeInterest) Reset() {
	*x = ChaincodeInterest{}
	mi := &file_peer_proposal_response_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChaincodeInterest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChaincodeInterest) ProtoMessage() {}

func (x *ChaincodeInterest) ProtoReflect() protoreflect.Message {
	mi := &file_peer_proposal_response_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChaincodeInterest.ProtoReflect.Descriptor instead.
func (*ChaincodeInterest) Descriptor() ([]byte, []int) {
	return file_peer_proposal_response_proto_rawDescGZIP(), []int{4}
}

func (x *ChaincodeInterest) GetChaincodes() []*ChaincodeCall {
	if x != nil {
		return x.Chaincodes
	}
	return nil
}

// ChaincodeCall defines a call to a chaincode.
// It may have collections that are related to the chaincode
type ChaincodeCall struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Name            string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	CollectionNames []string               `protobuf:"bytes,2,rep,name=collection_names,json=collectionNames,proto3" json:"collection_names,omitempty"`
	NoPrivateReads  bool                   `protobuf:"varint,3,opt,name=no_private_reads,json=noPrivateReads,proto3" json:"no_private_reads,omitempty"` // Indicates we do not need to read from private data
	NoPublicWrites  bool                   `protobuf:"varint,4,opt,name=no_public_writes,json=noPublicWrites,proto3" json:"no_public_writes,omitempty"` // Indicates we do not need to write to the chaincode namespace
	// The set of signature policies associated with states in the write-set
	// that have state-based endorsement policies.
	KeyPolicies []*common.SignaturePolicyEnvelope `protobuf:"bytes,5,rep,name=key_policies,json=keyPolicies,proto3" json:"key_policies,omitempty"`
	// Indicates we wish to ignore the namespace endorsement policy
	DisregardNamespacePolicy bool `protobuf:"varint,6,opt,name=disregard_namespace_policy,json=disregardNamespacePolicy,proto3" json:"disregard_namespace_policy,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *ChaincodeCall) Reset() {
	*x = ChaincodeCall{}
	mi := &file_peer_proposal_response_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChaincodeCall) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChaincodeCall) ProtoMessage() {}

func (x *ChaincodeCall) ProtoReflect() protoreflect.Message {
	mi := &file_peer_proposal_response_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChaincodeCall.ProtoReflect.Descriptor instead.
func (*ChaincodeCall) Descriptor() ([]byte, []int) {
	return file_peer_proposal_response_proto_rawDescGZIP(), []int{5}
}

func (x *ChaincodeCall) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ChaincodeCall) GetCollectionNames() []string {
	if x != nil {
		return x.CollectionNames
	}
	return nil
}

func (x *ChaincodeCall) GetNoPrivateReads() bool {
	if x != nil {
		return x.NoPrivateReads
	}
	return false
}

func (x *ChaincodeCall) GetNoPublicWrites() bool {
	if x != nil {
		return x.NoPublicWrites
	}
	return false
}

func (x *ChaincodeCall) GetKeyPolicies() []*common.SignaturePolicyEnvelope {
	if x != nil {
		return x.KeyPolicies
	}
	return nil
}

func (x *ChaincodeCall) GetDisregardNamespacePolicy() bool {
	if x != nil {
		return x.DisregardNamespacePolicy
	}
	return false
}

var File_peer_proposal_response_proto protoreflect.FileDescriptor

const file_peer_proposal_response_proto_rawDesc = "" +
	"\n" +
	"\x1cpeer/proposal_response.proto\x12\x06protos\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x15common/policies.proto\"\x9c\x02\n" +
	"\x10ProposalResponse\x12\x18\n" +
	"\aversion\x18\x01 \x01(\x05R\aversion\x128\n" +
	"\ttimestamp\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12,\n" +
	"\bresponse\x18\x04 \x01(\v2\x10.protos.ResponseR\bresponse\x12\x18\n" +
	"\apayload\x18\x05 \x01(\fR\apayload\x125\n" +
	"\vendorsement\x18\x06 \x01(\v2\x13.protos.EndorsementR\vendorsement\x125\n" +
	"\binterest\x18\a \x01(\v2\x19.protos.ChaincodeInterestR\binterest\"V\n" +
	"\bResponse\x12\x16\n" +
	"\x06status\x18\x01 \x01(\x05R\x06status\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12\x18\n" +
	"\apayload\x18\x03 \x01(\fR\apayload\"\\\n" +
	"\x17ProposalResponsePayload\x12#\n" +
	"\rproposal_hash\x18\x01 \x01(\fR\fproposalHash\x12\x1c\n" +
	"\textension\x18\x02 \x01(\fR\textension\"G\n" +
	"\vEndorsement\x12\x1a\n" +
	"\bendorser\x18\x01 \x01(\fR\bendorser\x12\x1c\n" +
	"\tsignature\x18\x02 \x01(\fR\tsignature\"J\n" +
	"\x11ChaincodeInterest\x125\n" +
	"\n" +
	"chaincodes\x18\x01 \x03(\v2\x15.protos.ChaincodeCallR\n" +
	"chaincodes\"\xa4\x02\n" +
	"\rChaincodeCall\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12)\n" +
	"\x10collection_names\x18\x02 \x03(\tR\x0fcollectionNames\x12(\n" +
	"\x10no_private_reads\x18\x03 \x01(\bR\x0enoPrivateReads\x12(\n" +
	"\x10no_public_writes\x18\x04 \x01(\bR\x0enoPublicWrites\x12B\n" +
	"\fkey_policies\x18\x05 \x03(\v2\x1f.common.SignaturePolicyEnvelopeR\vkeyPolicies\x12<\n" +
	"\x1adisregard_namespace_policy\x18\x06 \x01(\bR\x18disregardNamespacePolicyBk\n" +
	"\"org.hyperledger.fabric.protos.peerB\x17ProposalResponsePackageZ,github.com/hyperledger/fabric-protos-go/peerb\x06proto3"

var (
	file_peer_proposal_response_proto_rawDescOnce sync.Once
	file_peer_proposal_response_proto_rawDescData []byte
)

func file_peer_proposal_response_proto_rawDescGZIP() []byte {
	file_peer_proposal_response_proto_rawDescOnce.Do(func() {
		file_peer_proposal_response_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_peer_proposal_response_proto_rawDesc), len(file_peer_proposal_response_proto_rawDesc)))
	})
	return file_peer_proposal_response_proto_rawDescData
}

var file_peer_proposal_response_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_peer_proposal_response_proto_goTypes = []any{
	(*ProposalResponse)(nil),               // 0: protos.ProposalResponse
	(*Response)(nil),                       // 1: protos.Response
	(*ProposalResponsePayload)(nil),        // 2: protos.ProposalResponsePayload
	(*Endorsement)(nil),                    // 3: protos.Endorsement
	(*ChaincodeInterest)(nil),              // 4: protos.ChaincodeInterest
	(*ChaincodeCall)(nil),                  // 5: protos.ChaincodeCall
	(*timestamppb.Timestamp)(nil),          // 6: google.protobuf.Timestamp
	(*common.SignaturePolicyEnvelope)(nil), // 7: common.SignaturePolicyEnvelope
}
var file_peer_proposal_response_proto_depIdxs = []int32{
	6, // 0: protos.ProposalResponse.timestamp:type_name -> google.protobuf.Timestamp
	1, // 1: protos.ProposalResponse.response:type_name -> protos.Response
	3, // 2: protos.ProposalResponse.endorsement:type_name -> protos.Endorsement
	4, // 3: protos.ProposalResponse.interest:type_name -> protos.ChaincodeInterest
	5, // 4: protos.ChaincodeInterest.chaincodes:type_name -> protos.ChaincodeCall
	7, // 5: protos.ChaincodeCall.key_policies:type_name -> common.SignaturePolicyEnvelope
	6, // [6:6] is the sub-list for method output_type
	6, // [6:6] is the sub-list for method input_type
	6, // [6:6] is the sub-list for extension type_name
	6, // [6:6] is the sub-list for extension extendee
	0, // [0:6] is the sub-list for field type_name
}

func init() { file_peer_proposal_response_proto_init() }
func file_peer_proposal_response_proto_init() {
	if File_peer_proposal_response_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_peer_proposal_response_proto_rawDesc), len(file_peer_proposal_response_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_peer_proposal_response_proto_goTypes,
		DependencyIndexes: file_peer_proposal_response_proto_depIdxs,
		MessageInfos:      file_peer_proposal_response_proto_msgTypes,
	}.Build()
	File_peer_proposal_response_proto = out.File
	file_peer_proposal_response_proto_goTypes = nil
	file_peer_proposal_response_proto_depIdxs = nil
}
